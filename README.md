# COMS W4115 Fall 2025: Programming Assignment 2

## 1. Overview

For this assignment, you will implement the second stage of the compiler, a syntactic analyzer (parser) in C++. The assignment makes use of two tools: a parser generator called [`bison`](https://www.gnu.org/software/bison/manual/html_node/index.html) and a header for manipulating abstract syntax trees. The output of your parser will be an abstract syntax tree (AST). You will construct this AST using [semantic actions](https://www.gnu.org/software/bison/manual/html_node/Semantic-Actions.html) of the parser generator. 

You must refer to the grammar specification on the [MiniLang specsheet](https://docs.google.com/document/d/1QoHRme1exPaBUvD9djJaGjcuq7A--uN1LTLgmENxwws/edit?pli=1&tab=t.bevppp7stwqf#heading=h.s6btqiymhur) for completing this assignment.

You will submit `parser.y`, `lexer.l`, `astnode.hpp`, `astnode.cpp`, and a brief design write-up. This work must be done individually.

## 2. Flex and Bison

In the first assignment, we learnt how to build a handwritten scanner for `MiniLang`. While the language had very simple token constructs, you would have realised how tedious it is to actually build the scanner manually. There are a lot of edge cases that need to be handled, and even then you might miss some of them. For the purpose of this assignment, we would be replacing the scanner module of the compiler with a tool to help us automatically generate the lexer.

[Flex](https://westes.github.io/flex/manual/) is available on most Unixes/Linux systems. We have created the scanner specifications using flex in the file `lexer.l`. You are not expected to make changes to it, but feel free to check it out and understand how the tokens are created.

Flex and Bison are used together to automate the front end of a compiler. In this workflow, tokens are first defined in the bison grammar file using the `%token` directive; these tokens typically represent distinct language constructs such as identifiers, keywords, literals, and operators, and are conventionally written in all uppercase for clarity. Once these token types are declared, the lexer generated by flex returns these same tokens when analyzing the input stream.

The interface between flex and bison is standardized: after matching a pattern, the flex-generated lexer function (`yylex`) returns the corresponding token code defined by bison, ensuring that both modules communicate consistently. This approach guarantees that the parser, built by bison, receives the exact tokens it expects from the lexer, allowing seamless integration between lexical and syntactic analysis in the compiler pipeline. Remember that the flex-generated function `int yylex(void)` is automatically invoked by bison during parsing. Token values are stored in the `yylval` union and must match the types declared in your bison union.

## 3. Building your parser

Your first task during this lab will be to convert this verbal description of the language grammar into a grammar that is processed using bison. The grammar specification is provided [here](https://docs.google.com/document/d/1QoHRme1exPaBUvD9djJaGjcuq7A--uN1LTLgmENxwws/edit?tab=t.w2gwnd6ir94k#heading=h.g4phi25vl0ro). We have provided you with the template for the grammar file with entry points where you need to fill in your grammar definitions in the format that bison accepts. During your first step, do not worry about semantic actions corresponding to the grammar for building the AST. First implement the grammar correctly and test against sample output to see if your parser is integrated with flex properly, able to correctly parse the language and detect parsing errors.

Once you have the grammar for `MiniLang` down correctly, you should start adding semantic actions to your grammar rules to build and return the AST. We have provided you with an ASTNode template header file (`astnode.hpp`). We have also given a usage example in the bison template code. Feel free to extend the existing definition, or rewrite your own definitions, but all class definitions need to extend the `ASTNode` class. The `ASTNode` class is an interface that needs to be implemented by any new AST node classes that you define for your parser. Make sure to make any changes with respect to AST node definition in the `astnode.hpp` file itself. The implementation for the defined member functions must go in the file `astnode.cpp`.

**DO NOT DELETE `ASTNode` abstract base class.** The assignment's build structure relies on that. You should also keep in mind that all your custom defined AST node classes should extend and implement the `ASTNode` class.

We have enabled the option `parse-param` for the parser, which allows you to pass in a reference to an `ASTNode` pointer through the function `yyparse` from the driver code. If you are making any changes to the AST definition or the existing grammar definitions, make sure to make relevant changes to accommodate for this. Documentation around the parser function can be found [here](https://www.gnu.org/software/bison/manual/html_node/Parser-Function.html). I am also adding a small example below for clarity:

1.  Add the following in the prologue of your parser definition file:
    ```yacc
    parse-param { ASTNode** root }
    ```

2.  Since we would ideally want to return the root of the AST, in the semantic actions of the top-level grammar add the following semantic action:
    ```c++
    ASTNode* ast = new ASTNode();
    // Perform operations on the AST node
    *root = ast;
    ```

3.  In the driver method, you can have a piece of code as follows to retrieve the `ASTNode`:
    ```c++
    ASTNode* ast = nullptr;
    yyparse(&ast);
    ```

Note that this also changes the signature for the `yyerror` method and if you have a method override defined for `yyerror`, you might have to update it.

Your parser must throw a `ParserException` as soon as a syntax error is detected. The exception is defined in the `exception.hpp` file. You need to pass the line and column from the global [`yylloc`](https://www.gnu.org/software/bison/manual/html_node/Tracking-Locations.html) variable. Most of the heavy lifting with respect to location tracking is already done in the lexer definition file. This is an example of a parser error:

-   **Input**: `var x: int := 100`
-   **Output**: `Parser Error at line 1, column 17`

## 4. Deliverables

1.  `parser.y`: You need to fill in the language grammar along with the semantic actions to build the AST.
2.  `astnode.hpp`: You might need to extend or redefine node declarations and definitions in `ASTNode.hpp`. These structures would be used to build the AST for the parsed code sequence, which will be fed to later stages of the compilation process.
3.  `astnode.cpp`: This file contains all the implementations for the member functions defined in `astnode.hpp`.
4.  `lexer.l`: The flex definitions for lexical analysis are already done for you. You still might feel you need to edit it for your use case.

Do not modify `main.cpp` or the provided build infrastructure unless explicitly instructed. The autograder depends on their original structure.

## 5. Logistics

You are provided with a `Makefile` with the following targets:

1.  `debug`: This builds your parser in debug mode. This might be useful at the beginning for fixing any issues with your parser or the scanner. It generates a binary named `parser`.
2.  `parser`: This builds your parser without any debug statements. It generates a binary named `parser`.
3.  `clean`: This target removes any build files in your directory.

To run a provided testcase run the following command:
```bash
make parser && ./parser path/to/test_file
````

## 6\. Starter tips

1.  You might need to handle custom types for terminal symbols and non-terminal symbols. This can be done by adding these type definitions to the union in the prologue of the parser definition.

    ```yacc
    %union {
        std::string* text;
        int intval;
        double floatval;
        bool boolval;
        ProgramNode* program;
    }
    ```

2.  Unless otherwise noted, the default type associated with tokens (also referred to as terminal symbols) returned by the lexer is `int`. It can be declared as another type using the following syntax in the prologue of the parser definition:

    ```yacc
    %token <intval> INT_LITERAL
    ```

3.  To store semantic actions for non-terminal symbols which are present in the grammar rules in a custom type, you need to add these definitions in the union and define them as follows:

    ```yacc
    %nterm <program> program 
    // or 
    %type <program> program
    ```

4.  While we would not be running `valgrind` checks in this assignment, make sure to not have any memory leaks through your AST Node definitions or in the semantic actions. We might run these checks for future assignments. This might be useful: [Destructor Declaration](https://www.gnu.org/software/bison/manual/html_node/Destructor-Decl.html).

5.  Here is an example of how semantic actions can be defined for a `std::vector` type of non-terminal symbol. This logic can be extended to any kind of semantic action you would want to define.

    ```yacc
    %union {
        std::vector<ItemNode*>* item_list;
        ItemNode* item;
    }

    %type <item> item
    %type <item_list> item_list

    %%

    item_list:
        item_list item {
            $$ = $1; 
            $$->push_back($2);
        }
        | item {
            $$ = new std::vector<ItemNode*>;
            $$->push_back($1);
        }
    ;

    %%
    ```

6.  When declaring types inside `%union`, always use pointers for non-trivial types (e.g., `std::string*`, `ASTNode*`) to avoid memory management issues.

7.  Some tips for designing the AST node classes. You do not need to strictly follow them, but they might be helpful.

      * a. Create specific node types for each major language construct.
      * b. Follow the language grammar structure in your AST hierarchy.
      * c. Consider composition over inheritance for complex expressions.
      * d. Ensure proper memory management for AST children.
      * e. Don't create overly deep inheritance hierarchies.

8.  Consider using Bison's `%left`, `%right`, and `%precedence` directives to define operator precedence relationships.

9.  Test your parser incrementally - start with simple constructs before moving to complex programs.

## 7\. Submission

1.  Submit `parser.y`, `lexer.l`, `astnode.hpp`, `astnode.cpp` and `DESIGN.md` on Gradescope. The filenames should match exactly.
2.  After submission, the autograder will provide feedback, which you can use to make required modifications.
3.  Hidden test cases will also be run against your submission. Full score on the autograder cannot guarantee a full score on the assignment, hence test extensively.

The `DESIGN.md` file should discuss the following:

1.  What grammar rules did you define for the language?
2.  What types of AST nodes did you design for the language? What are the members of these AST nodes? What is each AST node supposed to track?
3.  The challenges you faced while designing or coding the parser.
4.  Reflections on flex vs the hand-written scanner in assignment 1.
5.  What did you learn during this assignment?
6.  Provide at least three distinct sample test cases you created in addition to the provided samples. These do not have to be semantically correct, but should go beyond the examples in the assignment.

## 8\. Grading

1.  You will be graded based on whether your parser is able to successfully parse code sequences which follow the grammar and throw an exception in cases where there is a syntax error.
2.  We also would test if you are able to report the correct line number and column number for `ParserException`s.
3.  There are no single correct answers for the design questions; their purpose is to help the teaching staff assess your understanding of **bison**, the assignment requirements and the syntactic analysis phase of a compiler.
4.  The code would not compile if there are any warnings or errors. This includes warnings for operator precedence. Make sure to define operator precedence based on the grammar specifications.

## 9\. Resources & Support

1.  `test/` directory has some sample tests and their outputs.
2.  Utilize EdStem and TA office hours for any doubts and questions.
3.  No late submissions are accepted.
4.  Please refer to the deadlines as available on GradeScope.
5.  Start early. This assignment might take some time to design and ramp up with bison.

-----

*This assignment was designed by Shivam Chaturvedi, Teaching Assistant, COMSW4115, Fall 2025.*